###一.阻塞\非阻塞和同步\非同步
阻塞和非阻塞并不是指CPU的阻塞，CPU只会不停的运行，没有阻塞的概念。

阻塞指的是发起I/O操作的进程，在I/O等待的时候,该进程被阻塞，直到I/O操作完成。

I/O等待包括等待数据的就绪和数据的复制。

非阻塞指当I/O没有就绪时，返回一个错误，比如EWOULDBLOCK标志，这样进程可以立即得到相应，下次再来轮询。

非阻塞I/O一般只针对于网络I/O，在socket的选项中，可以设置成O_NONBLOCK标志，这样对于socket的send()\recv()将使用非阻塞的方式。
阻塞要么发生在等待数据就绪，要么发生在数据的复制 。select在两个环节都会阻塞，但是优势在于可以返回多个就绪的文件描述符号。

AIO在发起I/O操作后就立即返回，不需要等待数据就绪。在数据复制完成后再通知，因此完全没有阻塞。

####同步\非同步

同步I/O操作引起请求进程阻塞，直到操作完成。
异步I/O操作则不会引起请求进程阻塞。
因此阻塞I/O,非阻塞I/O,I/O复用,信号I/O都属于同步I/O，只有AIO才是异步IO。




###二.I/O模型
####a.同步阻塞I/O
进程发起I/O操作，直到完成。比如accept()阻塞进程，直到有新的连接进来。

####b.同步非阻塞I/O
设置O_NONBLOCK标志后，响应的I/O操作将以非阻塞形式进行。如果数据没有准备好的话，将直接返回，而不是阻塞。

通过不断轮询来查看数据是否就绪。

####c.多路I/O复用
如果web站点连接很多，通过同步非阻塞的I/O，轮询各个文件描述符来获得就绪状态依旧效率低下。

因此需要有高性能的，对大量文件检查就绪状态的方案，然后只针对这些文件描述符访问。


#####传统的select
返回文件描述符的数组，如果就绪的文件描述符会被内核修改标志位，这样就可以获得这些文件描述符以便后续的操作。

缺点：


   * 单个进程能监视的文件描述符有大小限制，有些系统是直接将限制编译到lib里面的。

   * 所有文件描述符都会被返回，需要遍历才能得到已经就绪的文件描述符号
   * 整个数组的复制的开销也会随文件描述符个数成线性增长。

#####传统的poll
传统的poll和传统的select没有多大的区别，只不过它没有最大文件描述符的个数限制。但是同样存在复制的开销。

#####SIGIO
在I/O就绪的时候，发信号给请求进程，请求进程通过recvfrom进行数据的拷贝。
通过实时信号实现的select/poll 的通知方法。和select/poll的区别在于，SIGIO的文件就绪状态通知只有一次，下次调用时将不会通知。
因此SIGIO的性能比较好。

#####水平触发
传统的select和poll在报告就绪的文件描述符后，如果没有被及时处理，那么在下次调用的时候，这些文件描述符依旧存在，不会丢失就绪消息，所以被称为水平触发。


#####边缘触发
SIGIO就是边缘触发，它的文件就绪通知只有一次。

/dev/poll和/dev/epoll

/dev/poll通过虚拟的/dev/poll设备，将就绪的文件描述符写入这个设备，然后通过ioctl()能够获得就绪的文件描述符。

/dev/epoll和/dev/poll类似，增加了内存映射技术。
这两个都没有直接的内核支持。

#####epoll
linux 2.6下性能最好的多路I/O就绪通知方法，它同时支持水平触发和边缘触发。如果要使用边缘触发，需要在时间注册时增加EPOLLET选项。

Nginx的模型使用了边缘触发。

优点：


   * epoll()只返回就绪的文件描述符，减少了复制的开销
   * 通过epoll_ctl()注册文件描述符，一旦文件描述符就绪时，内核会采用类似callback的机制荀淑激活这个文件描述符，进程调用epoll_wait()时便得到通知。

kqueue
FreeBSD实现了kqueue，他和epoll优点类似，性能也接近。但是它的API很多平台不支持。

d.内存映射
通过建立内存和文件的映射，直接通过内存地址访问磁盘上的文件， 不需要再经过read()、write()系统调用，只需要mmap()调用来提升效率。mmap()可以建立内存映射。


####e.直接I/O


内存映射并不能从本质上提升I/O效率，因为数据依旧需要经历在磁盘到内核态、内核态到用户态之间的两次拷贝。

内核缓冲区是为了提升I/O效率，因为如果数据已经在缓冲区了，那么性能将得到提升。但是某些场景下，需要绕过这个缓冲区，

打开文件时指定O_DIRECT标志，就可以绕过内核缓冲区。

ps:
如果通过 O_SYNC 打开文件时，write()方法将在数据真正写到磁盘后才返回。

sendfile()调用可以直接将数据从磁盘复制到网卡，而不是，

将数据从磁盘拷贝到内核态，再从内核态拷贝到用户态，然后再到网卡所在的内核态，再到网卡。

####f.异步I/O AIO

AIO是非阻塞的异步I/O，理论上，进程发起I/O操作后，立即返回，等I/O操作完成后，通知进程。

但是目前没有很好的实现，Linux 2.6.16中的AIO是通过内核级线程库实现的，性能大打折扣。

