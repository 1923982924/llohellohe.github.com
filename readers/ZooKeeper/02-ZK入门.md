####ZooKeeper的一些基础
一些协调的原语经常被各个应用间共享，因此构建协调服务的一个基本方法就是使用一系列原语。

比如分布式锁构成了一个原语，它包含创建、获得和释放锁。

使用这样的设计会有两个弊端：
1.	要么能列举全所有原语，要么能不断扩展原语
2.	没有使用灵活的方式来实现现有原语

因此,ZooKeeper并没有直接暴露原语，而是暴露了类似文件系统的API。


#####(一).ZNode
ZNode是ZK树形结构的一个节点，它可以包含或者不包含数据。

ZK提供了如下API，用于操作ZNode。

1.	create path data
2.	delete path data
3.	exists path
3.	getdata path
4.	putdata path data
5.	getChildren path

ZK客户端通过建立一个Session会话，来连接ZK服务，通过这些API来操作ZNode。


#####(二).ZNode模式
目前ZNode包含持久模式和短暂模式ephemeral。

ephemeral模式指的是这个节点在session断了之后就会消失。

而持久模式的ZNode则会继续保持。

在master-worker模式下，ephemeral模式可以用于检测master或者worker是否挂掉。

如果使用持久模式的话，由于ZNode一直存在，无法感知到master或者worker是否已经crash。

ephemeral模式的节点也可以被主动删除。

除了持久模式和ephemeral模式外，ZNode还可以是有序的（自动分配自增ID到节点上，比如task-1,task-2,task-3）。

因此ZNode一共有四种形态：
1.	持久
2.	持久有序
3.	ephemeral
4.	ephemeral有序


#####(三).Watch和Notifications
Watch可以避免每次主动去请求数据是否变化，而是当ZNode变化时，来通知。

Watch是个一次性操作，每次收到通知后，必须重新watch，如果时间比较久或者ZNode更新频繁，在此时间之间，可能会有更新没有被通知到（还没来得急watch）。

ZNode的创建、删除和修改都可以被watch到。

遗留问题：ZK是否能得到每次节点通知？

ZK有个保证是，每次通知被送到每个客户端前，ZNode不会发生下一次的变化。

因此客户端可以保证看到的变化是顺序一致的。


#####(四).版本号
每个ZNode都会带有一个版本号，每次节点变化，版本号就会变化。

以此可以避免并发的更新问题（版本好不正确的更新会失败）。

