---
layout: post
category: Java
description: 深入Java内存模型读书笔记
keywords: Java内存模型, JMM , Java Memory Model
title: 深入Java内存模型读书笔记
tags: [java, JMM, java memory model]
summary: Java Memory Model
---

####一.简介
######并发编程的关键点
1.	线程间如何通信
2.	线程间如何同步


线程间的通信可以分为共享内存和消息两种。

同步是指用某种机制，保证线程间操作的顺序。

######JMM
Java的并发采用共享内存的方式，并且Java通过JMM(Java Memory Model)来控制线程间的通信。

共享的变量被放在主存中，每个线程都有本地内存，存放变量的副本。当然本地内存是个抽象概念，实际上并不存在。

JMM通过控制主存和线程本地内存的交互，来保证内存可见性。


####二.重排序
为了提高程序的性能，编译器和处理器会重排序指令。

重排序可以分为三类：

1.	编译器重排序
2.	处理器重排序
3.	内存系统重排序

处理器重排序可以通过内存屏障（memory barriers）来禁止特定类型的处理器指令重排序。

由于每个处理器都带有写缓冲区，因此处理器操作内存的顺序和实际内存发生的顺序可能不一样。

内存屏障可以保证某些指令的顺序，比如：

1.	LoadLoad
2.	StoreStore
3.	LoadStore
4.	StoreLoad

其中StoreLoad是全能的内存屏障，但是开销也很大，因为它需要所有处理器将写缓存刷新到内存中。


#####数据依赖性
如果两个操作访问同一变量，并且其中一个是写操作，比如写后写，写后读，读后写。

那么这两个操作则存在数据依赖。

因此编译器和处理器应该禁止这种重排序。

#####as-if-serial 语义
as-if-serial 是指不管怎么重排序，都不能影响程序的执行结果


#####数据竞争的定义
1.	一个线程对变量写
2.	另个线程对变量读
3.	读写没有进行同步

####三.Happens Before
JMM定义，如果一个操作的执行结果须对另个操作可见，那么这两个操作必须存在Happens-Before关系。

1.	一个线程中的每个操作都happens before后续的操作。
2.	对一个监视器的解锁happens before随后的对其加锁
3.	对于volatile的写，都happens before后续的读
4.	ABC传递性


####四.volatile
volatile的读写保证，线程都会从主存中操作（废弃本地内存的，使用主存的最新数据）

volatile的读前和读后，写前和写后都会插入响应的内存屏障指令。
####五.final
#####一.写重排序

1.	JMM编译器禁止将final的写重排序到构造函数之外
2.	通过插入StoreStore屏障来禁止处理器将写重排序到构造函数之外

#####写 final 域的重排序规则可以确保
在对象引用为任意线程可见之前,对象的 final 域已经被正确初始化过了,而普通域不具有这个保障,对象已经可见，但是可能没有被初始完成。

#####二.读重排序

在一个线程中,初次读对象引用与初次读该对象包含的 final 域,JMM 禁止处 理器重排序这两个操作(注意,这个规则仅仅针对处理器)。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障

#####读 final 域的重排序规则可以确保:

在读一个对象的 final 域之前,一定会先读包含 这个 final 域的对象的引用。


#####三.final 域是引用类型
在构造函数内对一个 final 引用的对象的成员域的写入,与随后在构造函数外把 这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序。

#####参考资料
深入理解 Java 内存模型_程晓明_InfoQ