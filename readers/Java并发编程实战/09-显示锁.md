###显示锁和内置锁
在Java 5.0之前，协调共享对象的访问时，只有synchronized和volatile。

Java 6.0增加了一种新的机制：ReentrantLock。

显示锁ReentrantLock和内置锁synchronized相比，实现了相同的语义，但是具有更高的灵活性。

1.	获取和释放的灵活性
2.	轮训锁和定时锁
3.	公平性

内置锁synchronized的获取和释放都在同一个代码块中，而显示锁则可以将锁的获得和释放分开。

同时，显示锁可以提供轮训锁和定时锁，同时可以提供公平锁或者非公平锁。

公平锁，是指线程将按照请求锁的顺序获得锁，而非公平所则允许插队。

###源代码分析

####Lock
`java.util.concurrent.locks.Lock`接口定义了显示锁的基本操作

1.	void lock();
2.	boolean tryLock();
3.	定时锁：boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
4.	void unlock(); 记得在finally中释放锁，避免忘记释放锁导致的“定时炸弹”
5.	Condition newCondition();


####ReentrantLock
ReentrantLock实现了接口Lock。

ReentrantLock内部亦采用了AQS实现。


####Condition

####wait\notify

在获得对象的监视器后，调用它的wait方法将导致当前线程等待，改线程将被放在对象的等待队列中，直到其它线程调用notify或者notifyAll方法通知它。

notify唤醒等待对象的线程。

[WaitAndNotify的代码例子。](https://github.com/llohellohe/cp/blob/master/src/yangqi/jcp/lock/WaitAndNotify.java)

wait和notify只能在拥有对象的锁后才能调用，否则将抛出IllegalMonitorStateException。它锁住的不是对象而是对象的线程。

####Condition
Condition和内置的wait\notify方法类似，用于实现线程间的通信。

它的方法有：

1.	void await() throws InterruptedException; //类似Object.wait
2.  boolean await(long time, TimeUnit unit) throws InterruptedException;
4.  void signal();  // 类似Object.notify()
5.  void signalAll();	// 类似Object.notifyAll()

ReentrantLock的newCondition方法返回Condition的实现。