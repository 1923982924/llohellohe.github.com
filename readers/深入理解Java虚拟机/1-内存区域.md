###第一章：走近Java（2013.12.14）

由于在64位系统中存在指针膨胀和各种数据类型对齐的问题，所以在64位系统上的java会额外增加10%-30%的内存消耗。


可以使用对象指针压缩功能（-XX:+UseCOmpressedOops）减少内存消耗。


JDK1.7中增加了java.util.concurrent.forkjoin包，Fork/Join模式是并行编程的经典方法。


注：fork/join模式还没搞懂


###第二章：Java内存区域与内存溢出异常（2013.12.14）


####虚拟机运行时区域


  1. 程序计数器（线程私有，用于记录下条指令的地址，如果是native方法，则为空）
  2. java虚拟机栈（同样是线程私有，虚拟机栈描述的是java方法执行的内存模型。方法执行的时候会创建一个栈桢stack frame，用于存放方法执行需要的局部变量、操作数栈、动态链接、方法出口等信息）
  3. 本地方法栈（虚拟机栈用于java方法，本地方法栈用于native方法）
  4. 堆（所有线程共享的内存区域，所有对象实例都在这里分配）
  5. 方法区（也是所有线程共享的区域，用于存放类信息、常量、静态变量、编译后的代码信息等），有些资料中称为永久区（perm区）。运行时常量池也是方法区的一部分，用于存放编译器生成的字面变量和符号引用。运行时常量池还包含动态生成的常量数据，比如String的intern()方法生成的数据。



####直接内存
直接内存并不属于虚拟机运行时数据区的一部分，而是通过native方法直接分配堆外内存，然后通过DirectByteByffer进行内存引用的操作。

####reference类型
对象的引用类型，可以通过两种方式实现。
a.通过句柄访问对象，reference类型指向的是句柄池中对应句柄的地址，由对应句柄指向实际对象。优势，在实际对象移动时，reference不需要修改，只需要修改句柄。
b.直接指向对象。比起a来，效率更高


hotspot采用的是b这种方式。